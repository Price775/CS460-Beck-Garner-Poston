Token: int
Rule: type_specifier -> INT
Token: main
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: (
Token: )
Rule: direct_declarator -> direct_declarator OPAREN CPAREN
Token: {
Rule: declarator -> direct_declarator
Token: char
Rule: type_specifier -> CHAR
Token: a
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: 'a'
Rule: constant -> CHARACTER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration
Token: char
Rule: type_specifier -> CHAR
Token: b
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: '\n'
Rule: constant -> CHARACTER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: char
Rule: type_specifier -> CHAR
Token: c
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: '\002'
Rule: constant -> CHARACTER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: char
Rule: type_specifier -> CHAR
Token: d
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: '\x23'
Rule: constant -> CHARACTER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: char
Rule: type_specifier -> CHAR
Token: e
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: '\u0001'
Rule: constant -> CHARACTER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: char
Rule: type_specifier -> CHAR
Token: f
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: '\U00000001'
Rule: constant -> CHARACTER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: int
Rule: type_specifier -> INT
Token: g
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: 0
Rule: constant -> INTEGER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: int
Rule: type_specifier -> INT
Token: h
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: 01
Rule: constant -> INTEGER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: int
Rule: type_specifier -> INT
Token: i
Rule: declaration_specifiers -> type_specifier
Rule: identifier -> IDENTIFIER
Rule: direct_declarator -> identifier
Token: =
Rule: declarator -> direct_declarator
Token: 0x2
Rule: constant -> INTEGER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: initializer -> assignment_expression
Rule: init_declarator -> declarator ASSIGN initializer
Rule: init_declarator_list -> init_declarator
Rule: declaration -> declaration_specifiers init_declarator_list SEMICOLON
Rule: declaration_list -> declaration_list declaration
Token: return
Token: 0
Rule: constant -> INTEGER_CONSTANT
Rule: primary_expression -> constant
Rule: postfix_expression -> primary_expression
Token: ;
Rule: unary_expression -> postfix_expression
Rule: cast_expression -> unary_expression
Rule: multiplicative_expression -> cast_expression
Rule: additive_expression -> multiplicative_expression
Rule: shift_expression -> additive_expression
Rule: relational_expression -> shift_expression
Rule: equality_expression -> relational_expression
Rule: and_expression -> equality_expression
Rule: exclusive_or_expression -> and_expression
Rule: inclusive_or_expression -> exclusive_or_expression
Rule: logical_and_expression -> inclusive_or_expression
Rule: logical_or_expression -> logical_and_expression
Rule: conditional_expression -> logical_or_expression
Rule: assignment_expression -> conditional_expression
Rule: expression -> assignment_expression
Rule: jump_statement -> RETURN expression SEMICOLON
Rule: statement -> jump_statement
Rule: statement_list -> statement
Token: }
Rule: compound_statement -> OBRACE declaration_list statement_list CBRACE
Rule: function_definition -> declaration_specifiers declarator compound_statement
Rule: external_declaration -> function_definition
Rule: translation_unit -> external_declaration
